module SystemHelper
  class SystemParser
    attr_reader :processors, :l2_cache, :bios, :usb_supports, :drive_supports
    attr_reader :total_memory, :memories, :harddrives, :opticals, :pcis
    attr_reader :system_model, :system_serial_number, :system_vendor, :mobo_model, :mobo_serial_number, :mobo_vendor, :macaddr
    attr_reader :model, :vendor, :serial_number

    attr_reader :string, :parser, :myparser

    include XmlHelper

    def SystemParser.parse(in_string)
      sp = nil
      parser = Parsers.select{|x| in_string.match(/#{x.match_string}/)}.first or return false
      begin
        sp = parser.new(in_string)
      rescue SystemParserException
        return false
      end
      return sp
    end

    def initialize(in_string)
      @string = in_string

      @parser = load_xml(@string) or raise SystemParserException

      do_work

      if model_is_usable(@system_model)
        @model = @system_model
      elsif model_is_usable(@mobo_model)
        @model = @mobo_model
      else
        @model = "(no model)"
      end

      if vendor_is_usable(@system_vendor)
        @vendor = @system_vendor
      elsif vendor_is_usable(@mobo_vendor)
        @vendor = @mobo_vendor
      else
        @vendor = "(no vendor)"
      end

      if serial_is_usable(@system_serial_number)
        @serial_number = @system_serial_number
      elsif serial_is_usable(@mobo_serial_number)
        @serial_number = @mobo_serial_number
      elsif mac_is_usable(@macaddr)
        @serial_number = @macaddr
      else
        @serial_number = "(no serial number)"
      end
    end

    def find_system_id
      if @serial_number != "(no serial number)" && (found_system = System.find(:first, :conditions => {:serial_number => @serial_number, :vendor => @vendor, :model => @model}, :order => :id))
        return found_system.id
      else
        return nil
      end
    end

    # TODO: remove these
    attr_reader :parser

    def myparser
      self
    end

    private

    def is_usable(value, list_of_generics = [], check_size = false)
      return (value != nil && value != "" && !list_of_generics.include?(value) && (check_size == false || value.strip.length > 5))
    end

    def mac_is_usable(value)
      return is_usable(value)
    end

    def serial_is_usable(value)
      list_of_generics = Generic.find(:all).collect(&:value)
      return is_usable(value, list_of_generics, true)
    end

    def vendor_is_usable(value)
      list_of_generics = Generic.find(:all, :conditions => ['only_serial = ?', false]).collect(&:value)
      return is_usable(value, list_of_generics)
    end

    def model_is_usable(value)
      list_of_generics = Generic.find(:all, :conditions => ['only_serial = ?', false]).collect(&:value)
      return is_usable(value, list_of_generics)
    end
  end

  class SystemParserException < Exception
  end

  class LshwSystemParser < SystemParser
    include XmlHelper

    def self.match_string
      "generated by lshw"
    end

    def do_work
      # system data

      @parser.xml_foreach("//*[@class='system']") {
        @system_model ||= @parser._xml_value_of("/node/product")
        @system_serial_number ||= @parser._xml_value_of("/node/serial")
        @system_vendor ||= @parser._xml_value_of("/node/vendor")
        @mobo_model ||= @parser._xml_value_of("//*[contains(@id, 'core')]/product")
        @mobo_serial_number ||= @parser._xml_value_of("//*[contains(@id, 'core')]/serial")
        @mobo_vendor ||= @parser._xml_value_of("//*[contains(@id, 'core')]/vendor")
        @macaddr ||= @parser._xml_value_of("//*[contains(@id, 'network') or contains(description, 'Ethernet')]/serial")
      }

      # computer section

      @processors = []
      @parser.xml_foreach("//*[@class='processor']") do
        if @parser.xml_if("product")
          h = OpenStruct.new
          h.processor = @parser.xml_value_of("product")
          h.speed = (@parser.xml_if("capacity") && false ? @parser.xml_value_of("capacity") : @parser.xml_value_of("size")).to_hertz if @parser.xml_if("capacity") || @parser.xml_if("size")

          h.supports = []
          find_these = ["lm", "svm", "vmx", "x86-64"]
          @parser.xml_foreach("capabilities/capability") do
            if find_these.include?(@parser.xml_value_of("@id"))
              h.supports << @parser.xml_value_of(".")
            end
          end
          @processors << h
        end
      end

      @bios = @parser.xml_value_of("//*[contains(@id, 'firmware')]/version")

      @parser.find_the_biggest("//node[contains(@id, 'usbhost')]/capabilities/capability", "USB ") do |value|
        @usb_supports = value
      end

      @drive_supports = []
      a = []; @parser.xml_foreach("//*[contains(@id, 'storage') or contains(@id, 'ide') or contains(@id, 'scsi')]") do a << @parser.xml_value_of(".//product") + @parser.xml_value_of(".//description") end
      a.collect{|x| if x.match(/(scsi|sata|ide)/i); $1.upcase; else nil; end}.delete_if{|x| x.nil?}.uniq.each do |x|
        @drive_supports << x
      end

      @l2_cache = []
      @parser.xml_foreach("//*[@class='memory']") do
        if @parser.xml_value_of("description") == "L2 cache"
          @l2_cache << @parser.xml_value_of("size").to_bytes # the description is always L2 cache
        end
      end

      # hard drives
      @harddrives = []

      @parser.xml_foreach("//*[contains(@id, 'disk')]") do
        h = OpenStruct.new
        h.name = @parser.xml_value_of("logicalname")
        h.my_type = (@parser.do_with_parent do @parser.xml_value_of(".//product") + @parser.xml_value_of(".//description") end).match(/(scsi|sata|ide)/i) ? $1.upcase : "Unknown"
        h.vendor = @parser.xml_value_of("vendor")
        h.model = @parser.xml_value_of("product")
        h.size = @parser.xml_if("size") ? @parser.xml_value_of("size").to_bytes(0, false, false) : @parser.xml_if("capacity") ? @parser.xml_value_of("capacity").to_bytes(0, false, false) : nil
        h.volumes = []
        @parser.xml_foreach(".//*[contains(@id, 'volume')]") do
          v = OpenStruct.new
          v.name = @parser.xml_value_of("logicalname")
          v.description = @parser.xml_value_of("description")
          v.size = @parser.xml_value_of("capacity").to_bytes(0, false, false)
          h.volumes << v
        end
        @harddrives << h
      end

      # memory
      @parser.xml_foreach("//*[contains(@id, 'memory')]") do
        if @parser.xml_if("size")
          @total_memory = @parser.xml_value_of("size").to_bytes(1)
        end
      end

      @memories = []

      @parser.xml_foreach(".//*[contains(@id, 'bank')]") do
        m = OpenStruct.new
        m.bank = @parser.xml_value_of("@id").sub(/^bank:/, "")
        m.description = @parser.xml_value_of("description")
        m.size = @parser.xml_value_of("size").to_bytes if @parser.xml_if("size")
        @memories << m
      end

      # optical
      @opticals = []

      @parser.xml_foreach("//node[contains(@id, 'cdrom')]") do
        h = OpenStruct.new
        h.name = @parser.xml_value_of("logicalname")
        h.description = @parser.xml_value_of("description")
        a = []
        @parser.xml_foreach("capabilities/capability") do
          a << [@parser.xml_value_of("."), @parser.xml_value_of("@id")]
        end
        a = a.select{|a| a[1].match(/(cd|dvd)/)}
        h.capabilities = a.map{|x| x[0]}.to_sentence
        h.my_type = (@parser.do_with_parent do @parser.xml_value_of("product") + @parser.xml_value_of("description") end).match(/(scsi|sata|ide)/i) ? $1.upcase : "Unknown"
        h.model = @parser.xml_value_of("product")
        @opticals << h
      end

      # pci
      
    end
  end


  class PlistSystemParser < SystemParser
    def self.match_string
      "DOCTYPE plist"
    end

    def do_work
      @result = Nokogiri::PList::Parser.parse(@parser.my_node)
      begin
        @macaddr = @result.map{|x| x["_items"]}.flatten.select{|x| x["_name"] == "Built-in Ethernet"}.first["Ethernet"]["MAC Address"]
      rescue
      end
    end
  end

  SystemParser::Parsers = [PlistSystemParser, LshwSystemParser]
end
