<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Searchable - ActiveRecord Integration for Rails</title>

<style type="text/css">
body {
  font-family: Verdana, Arial, Helvetica, sans-serif;
  font-size: 11px;
}

ul {
  list-style-type: none;
  margin: 0px;
  padding: 0px;
}

#content {
  border-right: 1px solid #eeeeee;
  margin-left: 2em;
  padding-right: 1em;
  width: 40em;
}

#menu {
  background-color: #eeeeee;
  position: absolute;
  margin-top: 1em;
  margin-left: 44em;
  padding: 5px;
}

#menu h2 {
  font-size: 13px;
  margin: 0px;
  padding: 0px;
}
</style></head>

<body>
<div id="menu">
<h2>Links</h2>
<ul>
  <li><a title="RubyForge Project Page" href="http://rubyforge.org/projects/searchable/">RubyForge Project Page</a></li>
  <li><a title="Searchable/Java" href="http://mojodna.net/searchable/">Searchable/Java</a></li>
  <li><a title="RDoc" href="http://searchable.rubyforge.org/api/">API Documentation</a></li>
</ul>
</div>
<div id="content">

<h1 id="searchable">Searchable</h1>

<h2 id="activerecord_integration_for_rails">ActiveRecord Integration for Rails</h2>

<h3 id="overview">Overview</h3>

<p><em>Searchable is a Rails plugin that uses the <a href="http://ferret.davebalmain.com/trac">Ferret</a> toolkit (a <a href="http://lucene.apache.org/">Lucene</a> derivative) or <a href="http://incubator.apache.org/solr/">Solr</a> to provide full-text search integration with ActiveRecord.</em></p>

<h3 id="notes">Notes</h3>

<p>The documentation has not yet been updated to reflect the Solr backend and the API changes required by Ferret 0.10.x.</p>

<h3 id="compatibility">Compatibility</h3>

<p>Searchable (with Ferret) has been tested with Rails 1.0+.  Ferret 0.10.x is currently required (if using the Ferret backend).</p>

<h3 id="installation">Installation</h3>

<pre><code>script/plugin install -x svn://rubyforge.org/var/svn/searchable/trunk
</code></pre>

<h3 id="configuration">Configuration</h3>

<p><em>environment.rb:</em></p>

<pre><code># Globally override the default index path ("#{RAILS_ROOT}/db/ferret_index")
MojoDNA::Searchable::Indexer::default_index_path "#{RAILS_ROOT}/db/my_index"

# Globally override the default analyzer (Ferret::Analysis::StandardAnalyzer)
MojoDNA::Searchable::Indexer::default_analyzer Ferret::Analysis::StopAnalyzer

# Force Searchable to use the DRb backend (default: local)
MojoDNA::Searchable::remote
</code></pre>

<h3 id="indexing_models">Indexing Models</h3>

<p>The are 3 ways to specify indexing strategies for models.</p>

<h4 id="using_defaults">Using Defaults</h4>

<p>The first way is to simply <code>include Searchable</code> which triggers Searchable&#8217;s default behavior, which is to index all attributes returned by <code>Model.content_columns</code> using each attributes name as its field name within the index.</p>

<p>For example:</p>

<pre><code>class Person &lt; ActiveRecord::Base
    include Searchable

    # attrs: first_name, last_name
end
</code></pre>

<p>This model can then be searched:</p>

<pre><code>Person.search("seth")
</code></pre>

<p>This will attempt to match &#8220;<em>seth</em>&#8221; on all fields available in the index (<em>first_name</em> and <em>last_name</em>).  If you wish to target a specific field:</p>

<pre><code>Person.search("first_name: seth")
</code></pre>

<h4 id="indexing_dsl">Indexing DSL</h4>

<p>Searchable includes a DSL which allows one to exercise fine-grained control over indexing strategies.</p>

<p>An overly complex example:</p>

<pre><code>class Person &lt; ActiveRecord::Base
    include Searchable

    # attrs: first_name, last_name, address (an Address object)
    has_one :address

    # (locally) override the index path
    index_path "#{RAILS_ROOT}/db/person_index"

    # (locally) override the default analyzer for this model
    default_analyzer Ferret::Analysis::StopAnalyzer

    # index the person's first name (specifying defaults as a hash)
    index_attr :first_name, :boost =&gt; 1.0, :indexed =&gt; true, :tokenized =&gt; true, :stored =&gt; false, :indexed_name =&gt; "first_name", :sortable =&gt; false

    # index the person's last name (overriding some defaults using the block format)
    index_attr :last_name do |attr|
        attr.indexed_name "last_name"

        # alias "surname" and "sn" to this field so queries for "sn:fitzsimmons" will work
        attr.aliases ["surname", "sn"]
        attr.boost 2.0
        attr.indexed true
        attr.tokenized true
        attr.stored false

        # allow resultsets to be sortable by last name
        attr.sortable true
    end

    # index (part of) the person's address, including attributes of the address association
    index_attr :address do |attr|
        attr.include :city, :boost =&gt; 0.75
        attr.include :state do |state|
            # alias state to province to queries for "address.province: MA" will work
            state.aliases ["province"]
            state.boost 0.75
        end
        attr.include :country, :boost =&gt; 0.75
    end
end
</code></pre>

<h4 id="custom_to_doc">Custom to_doc</h4>

<p>If the DSL doesn&#8217;t provide enough flexibility and you want to be
even more specific about how attributes are indexed, you can provide
your own to_doc method that will be used in conjunction with the DSL to
provide additional fields to the index.</p>

<p>If you have field/value pairs where you want the field name used as a field name:</p>

<pre><code># custom to_doc to handle field/value pairings
def to_doc(doc)
  fields.each do |field|
    f.values.each do |value|
      doc &lt;&lt; Indexer::create_field("#{field.name}", value)
    end
  end
  doc
end
</code></pre>

<h4 id="creating_the_index">Creating the Index</h4>

<p>The instance method <code>model.add_to_index</code> is used to add
an instance of a model to the appropriate index. Searchable will handle
creation of the index files and will remove any existing documents
corresponding to the instance being indexed. <code>model.remove_from_index</code>
is used to explicitly remove an instance from the index. Both methods
are registered as ActiveRecord callbacks, so if an object is created,
updated, or deleted, it will be created, updated, or deleted within the
index as well.</p>

<p>If you wish to index all instances of a given model, use the class method <code>Model.index_all</code>.
This will load all instances of a model (in batches of 500) and add
them to the index. By default, it creates a temporary index and copies
it over the existing index when it&#8217;s done being processed. This avoids
any interruption of service if this is being done to rebuild an index
on a live site. When running in local mode, avoid calling this from a
process that shouldn&#8217;t block (i.e. a FastCGI process).</p>

<h3 id="searching">Searching</h3>

<p>By now, you&#8217;ve seen the basics of how to search for instances of models:</p>

<pre><code>all_people_named_or_living_in_kerry = Person.search("kerry")
all_people_named_seth = Person.search("first_name: seth")
</code></pre>

<p>You can pass the <code>search</code> method either a String or a
Ferret Query that you&#8217;ve constructed yourself. If you pass in a String,
you can use the Ferret Query Language, which is very similar to <a href="http://lucene.apache.org/java/docs/queryparsersyntax.html">Lucene&#8217;s query syntax</a>.</p>

<p>By default, all results returned by <code>search</code> will be fully-loaded models (loaded using the appropriate <code>find</code> method).  If you wish to have just the ids returned, pass <code>:load =&gt; false</code> as part of the options hash.</p>

<pre><code>Person.search("seth", :load =&gt; false)
</code></pre>

<p>You can take advantage of attributes that have been marked as sortable (reversible):</p>

<pre><code>Person.search("seth", :sort_by =&gt; :last_name)
Person.search("seth", :sort_by =&gt; :last_name, :reverse =&gt; true )
</code></pre>

<p>Specify the default fields to be searched:</p>

<pre><code>Person.search("seth", :default_fields =&gt; ["first_name, last_name"])
</code></pre>

<p>Support pagination by using <code>:offset</code> and <code>:limit</code>:</p>

<pre><code>Person.search("seth", :limit =&gt; 10, :offset =&gt; 10)
</code></pre>

<h3 id="remote_mode_drb">Remote Mode (DRb)</h3>

<p>Searchable includes a DRb backend that allows AR models to
communicate with a single &#8220;search server&#8221;. This is a much better option
for clustered environments where index consistency is important and
there are enough reads and writes that index file locking issues come
into play.</p>

<p>To enable remote mode, add this to your environment.rb:</p>

<pre><code># Force Searchable to use the DRb backend (default: local)
MojoDNA::Searchable::remote
</code></pre>

<p>And copy the appropriate scripts to your <code>script</code> directory:</p>

<pre><code>for f in searchable indexer; do
    cp vendor/plugins/acts_as_searchable/script/$f script
    chmod 755 script/$f
done
</code></pre>

<p>You can then use Searchable in exactly the same manner. The only
difference is that your index(es) will be stored on the server running
the DRb service.</p>

<p>To start the DRb service:</p>

<pre><code>script/searchable &amp;
script/indexer &amp;
</code></pre>

<h3 id="additional_backends">Additional backends</h3>

<p>Alternative backends can be created by following the example of <code>LocalSearchable</code> and <code>RemoteSearchable</code>.  You&#8217;ll also need to modify <code>Searchable</code> to include the appropriate backend under appropriate conditions.</p>

<h3 id="the_future">The Future</h3>

<p>Support for searching across multiple models has not yet been added.
Nor has support for searching across multiple indexes. Dates should be
handled for more efficient querying.</p>


</div>
</body></html>
